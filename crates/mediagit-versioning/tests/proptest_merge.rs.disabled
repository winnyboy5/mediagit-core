//! Property-Based Tests for Merge Operations
//!
//! Uses proptest to verify merge properties with random data:
//! - Merge commutativity where applicable
//! - Merge idempotence
//! - Conflict detection consistency
//! - LCA correctness properties

use mediagit_versioning::{
    commit::{Commit, CommitMetadata},
    lca::find_lowest_common_ancestor,
    merge::{MergeStrategy, Merger},
    oid::ObjectId,
};
use proptest::prelude::*;
use std::collections::HashMap;
use tempfile::TempDir;

/// Generate random commit message
fn arb_commit_message() -> impl Strategy<Value = String> {
    "[a-zA-Z0-9 ]{10,100}"
}

/// Generate random text content for merging
fn arb_text_content() -> impl Strategy<Value = Vec<u8>> {
    prop::collection::vec(prop::char::range('a', 'z').prop_map(|c| c as u8), 100..1000)
}

/// Generate random line-based text content
fn arb_line_text() -> impl Strategy<Value = Vec<u8>> {
    prop::collection::vec("(line [0-9]{1,3}\n)", 5..50)
        .prop_map(|lines| lines.join("").into_bytes())
}

// ============================================================================
// Merge Roundtrip Property Tests
// ============================================================================

#[tokio::test]
async fn proptest_merge_no_conflict_is_deterministic() {
    let mut runner = proptest::test_runner::TestRunner::default();

    runner
        .run(
            &(arb_line_text(), arb_line_text(), arb_line_text()),
            |(base, ours, theirs)| {
                tokio::runtime::Runtime::new().unwrap().block_on(async {
                    let temp_dir = TempDir::new().unwrap();
                    let merger = Merger::new(temp_dir.path().to_path_buf());

                    // Ensure no conflicts by making changes to different parts
                    let mut ours_modified = base.clone();
                    ours_modified.extend_from_slice(b"ours addition\n");

                    let mut theirs_modified = base.clone();
                    theirs_modified.insert(0, b't');
                    theirs_modified.insert(1, b'h');

                    let result1 = merger
                        .merge_contents(&base, &ours_modified, &theirs_modified, &MergeStrategy::Recursive)
                        .await;

                    let result2 = merger
                        .merge_contents(&base, &ours_modified, &theirs_modified, &MergeStrategy::Recursive)
                        .await;

                    // Same inputs should produce same results (determinism)
                    prop_assert_eq!(result1.is_ok(), result2.is_ok());

                    if let (Ok(merged1), Ok(merged2)) = (result1, result2) {
                        prop_assert_eq!(merged1, merged2);
                    }

                    Ok(())
                })
            },
        )
        .unwrap();
}

#[tokio::test]
async fn proptest_merge_empty_changes() {
    let mut runner = proptest::test_runner::TestRunner::default();

    runner
        .run(&arb_line_text(), |base| {
            tokio::runtime::Runtime::new().unwrap().block_on(async {
                let temp_dir = TempDir::new().unwrap();
                let merger = Merger::new(temp_dir.path().to_path_buf());

                // Merging identical versions should return base
                let result = merger
                    .merge_contents(&base, &base, &base, &MergeStrategy::Recursive)
                    .await
                    .unwrap();

                prop_assert_eq!(base, result);

                Ok(())
            })
        })
        .unwrap();
}

#[tokio::test]
async fn proptest_merge_one_sided_change() {
    let mut runner = proptest::test_runner::TestRunner::default();

    runner
        .run(&(arb_line_text(), arb_line_text()), |(base, modified)| {
            tokio::runtime::Runtime::new().unwrap().block_on(async {
                let temp_dir = TempDir::new().unwrap();
                let merger = Merger::new(temp_dir.path().to_path_buf());

                // One side changed, other side unchanged
                let result = merger
                    .merge_contents(&base, &modified, &base, &MergeStrategy::Recursive)
                    .await
                    .unwrap();

                // Result should be the modified version
                prop_assert_eq!(modified, result);

                Ok(())
            })
        })
        .unwrap();
}

#[tokio::test]
async fn proptest_merge_append_only() {
    let mut runner = proptest::test_runner::TestRunner::default();

    runner
        .run(&(arb_line_text(), arb_line_text(), arb_line_text()), |(base, ours_add, theirs_add)| {
            tokio::runtime::Runtime::new().unwrap().block_on(async {
                let temp_dir = TempDir::new().unwrap();
                let merger = Merger::new(temp_dir.path().to_path_buf());

                // Both sides append different content (no conflict)
                let mut ours = base.clone();
                ours.extend_from_slice(b"\n--- OURS ---\n");
                ours.extend_from_slice(&ours_add);

                let mut theirs = base.clone();
                theirs.extend_from_slice(b"\n--- THEIRS ---\n");
                theirs.extend_from_slice(&theirs_add);

                let result = merger
                    .merge_contents(&base, &ours, &theirs, &MergeStrategy::Recursive)
                    .await;

                // Append-only merges should generally succeed
                prop_assert!(result.is_ok());

                if let Ok(merged) = result {
                    // Merged result should contain base content
                    prop_assert!(merged.starts_with(&base));
                }

                Ok(())
            })
        })
        .unwrap();
}

// ============================================================================
// LCA Property Tests
// ============================================================================

#[test]
fn proptest_lca_reflexive() {
    proptest!(|(message in arb_commit_message())| {
        let mut commits = HashMap::new();

        let oid = ObjectId::from_hex(&format!("{:064x}", 12345)).unwrap();
        let metadata = CommitMetadata {
            author: "Test Author".to_string(),
            email: "test@example.com".to_string(),
            message: message.clone(),
            timestamp: 1_000_000,
        };

        let commit = Commit {
            oid: oid.clone(),
            tree_oid: ObjectId::from_hex(&format!("{:064x}", 99999)).unwrap(),
            parents: vec![],
            metadata,
        };

        commits.insert(oid.clone(), commit);

        // LCA of a commit with itself should be itself
        let lca = find_lowest_common_ancestor(&oid, &oid, &commits).unwrap();
        prop_assert_eq!(Some(oid), lca);
    });
}

#[test]
fn proptest_lca_linear_history() {
    proptest!(|(chain_length in 2usize..20)| {
        let mut commits = HashMap::new();
        let mut prev_oid = None;
        let mut all_oids = Vec::new();

        // Create linear history
        for i in 0..chain_length {
            let oid = ObjectId::from_hex(&format!("{:064x}", i)).unwrap();
            let metadata = CommitMetadata {
                author: "Test Author".to_string(),
                email: "test@example.com".to_string(),
                message: format!("Commit {}", i),
                timestamp: 1_000_000 + i as i64,
            };

            let commit = Commit {
                oid: oid.clone(),
                tree_oid: ObjectId::from_hex(&format!("{:064x}", i + 10000)).unwrap(),
                parents: prev_oid.iter().cloned().collect(),
                metadata,
            };

            all_oids.push(oid.clone());
            commits.insert(oid.clone(), commit);
            prev_oid = Some(oid);
        }

        // LCA of any two commits in linear history should be the earlier one
        if chain_length >= 2 {
            let oid1 = all_oids[0].clone();
            let oid2 = all_oids[chain_length - 1].clone();

            let lca = find_lowest_common_ancestor(&oid1, &oid2, &commits).unwrap();
            prop_assert_eq!(Some(oid1), lca);
        }
    });
}

#[test]
fn proptest_lca_commutative() {
    proptest!(|(idx1 in 0usize..10, idx2 in 0usize..10)| {
        let mut commits = HashMap::new();

        // Create simple branching history
        let base_oid = ObjectId::from_hex(&format!("{:064x}", 0)).unwrap();
        let base_metadata = CommitMetadata {
            author: "Test Author".to_string(),
            email: "test@example.com".to_string(),
            message: "Base commit".to_string(),
            timestamp: 1_000_000,
        };
        let base_commit = Commit {
            oid: base_oid.clone(),
            tree_oid: ObjectId::from_hex(&format!("{:064x}", 10000)).unwrap(),
            parents: vec![],
            metadata: base_metadata,
        };
        commits.insert(base_oid.clone(), base_commit);

        let oid1 = ObjectId::from_hex(&format!("{:064x}", idx1 + 1)).unwrap();
        let oid2 = ObjectId::from_hex(&format!("{:064x}", idx2 + 1)).unwrap();

        // Create two branches from base
        for (idx, oid) in [(idx1, &oid1), (idx2, &oid2)] {
            let metadata = CommitMetadata {
                author: "Test Author".to_string(),
                email: "test@example.com".to_string(),
                message: format!("Commit {}", idx),
                timestamp: 1_000_001 + idx as i64,
            };
            let commit = Commit {
                oid: oid.clone(),
                tree_oid: ObjectId::from_hex(&format!("{:064x}", idx + 20000)).unwrap(),
                parents: vec![base_oid.clone()],
                metadata,
            };
            commits.insert(oid.clone(), commit);
        }

        // LCA should be commutative: LCA(A, B) = LCA(B, A)
        let lca1 = find_lowest_common_ancestor(&oid1, &oid2, &commits).unwrap();
        let lca2 = find_lowest_common_ancestor(&oid2, &oid1, &commits).unwrap();

        prop_assert_eq!(lca1, lca2);
    });
}

// ============================================================================
// Conflict Detection Property Tests
// ============================================================================

#[tokio::test]
async fn proptest_identical_changes_no_conflict() {
    let mut runner = proptest::test_runner::TestRunner::default();

    runner
        .run(&(arb_line_text(), arb_line_text()), |(base, modification)| {
            tokio::runtime::Runtime::new().unwrap().block_on(async {
                let temp_dir = TempDir::new().unwrap();
                let merger = Merger::new(temp_dir.path().to_path_buf());

                // Both sides make identical changes - no conflict
                let result = merger
                    .merge_contents(&base, &modification, &modification, &MergeStrategy::Recursive)
                    .await
                    .unwrap();

                // Result should be the modification (both sides agree)
                prop_assert_eq!(modification, result);

                Ok(())
            })
        })
        .unwrap();
}

#[tokio::test]
async fn proptest_merge_strategies_consistency() {
    let mut runner = proptest::test_runner::TestRunner::default();

    runner
        .run(&arb_line_text(), |base| {
            tokio::runtime::Runtime::new().unwrap().block_on(async {
                let temp_dir = TempDir::new().unwrap();
                let merger = Merger::new(temp_dir.path().to_path_buf());

                // When there are no changes, all strategies should agree
                let recursive = merger
                    .merge_contents(&base, &base, &base, &MergeStrategy::Recursive)
                    .await
                    .unwrap();

                let ours = merger
                    .merge_contents(&base, &base, &base, &MergeStrategy::Ours)
                    .await
                    .unwrap();

                let theirs = merger
                    .merge_contents(&base, &base, &base, &MergeStrategy::Theirs)
                    .await
                    .unwrap();

                // All strategies should return base when nothing changed
                prop_assert_eq!(base, recursive);
                prop_assert_eq!(base, ours);
                prop_assert_eq!(base, theirs);

                Ok(())
            })
        })
        .unwrap();
}

// ============================================================================
// Edge Case Property Tests
// ============================================================================

#[tokio::test]
async fn proptest_merge_empty_base() {
    let mut runner = proptest::test_runner::TestRunner::default();

    runner
        .run(&(arb_line_text(), arb_line_text()), |(ours, theirs)| {
            tokio::runtime::Runtime::new().unwrap().block_on(async {
                let temp_dir = TempDir::new().unwrap();
                let merger = Merger::new(temp_dir.path().to_path_buf());

                let base = b"";

                // Merging with empty base
                let result = merger
                    .merge_contents(base, &ours, &theirs, &MergeStrategy::Recursive)
                    .await;

                // Should handle gracefully (might conflict or succeed depending on content)
                prop_assert!(result.is_ok() || result.is_err());

                Ok(())
            })
        })
        .unwrap();
}

#[tokio::test]
async fn proptest_merge_single_line() {
    let mut runner = proptest::test_runner::TestRunner::default();

    runner
        .run(&("[a-z]{10,50}", "[a-z]{10,50}", "[a-z]{10,50}"), |(base, ours, theirs)| {
            tokio::runtime::Runtime::new().unwrap().block_on(async {
                let temp_dir = TempDir::new().unwrap();
                let merger = Merger::new(temp_dir.path().to_path_buf());

                let result = merger
                    .merge_contents(
                        base.as_bytes(),
                        ours.as_bytes(),
                        theirs.as_bytes(),
                        &MergeStrategy::Recursive,
                    )
                    .await;

                // Single line merges should either succeed or detect conflict
                prop_assert!(result.is_ok() || result.is_err());

                Ok(())
            })
        })
        .unwrap();
}
